-- Learn N Grow schema (incremental numeric IDs)
-- NOTE: This script drops and recreates students/finances/attendance tables.

-- Keep updated_at consistent
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- Recreate tables so ID type is guaranteed as BIGINT identity
drop table if exists public.attendance;
drop table if exists public.finances;
drop table if exists public.students;

create table public.students (
  id bigint generated by default as identity primary key,
  name text not null,
  phone text not null,
  batch text not null default 'morning' check (batch in ('morning', 'evening')),
  join_date date not null default current_date,
  status text not null default 'active' check (status in ('active', 'inactive')),
  monthly_fee numeric(12,2) not null default 3000 check (monthly_fee >= 0),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table public.finances (
  id bigint generated by default as identity primary key,
  transaction_date date not null default current_date,
  category text not null,
  type text not null check (type in ('income', 'expense')),
  amount numeric(12,2) not null check (amount >= 0),
  status text not null default 'paid' check (status in ('paid', 'pending')),
  description text,
  note text,
  student_id bigint references public.students(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  check (
    (category = 'Student Fee' and type = 'income')
    or (category <> 'Student Fee')
  )
);

create table public.attendance (
  id bigint generated by default as identity primary key,
  student_id bigint not null references public.students(id) on delete cascade,
  student_name text not null,
  batch text not null default 'morning' check (batch in ('morning', 'evening')),
  attendance_date date not null,
  status text not null check (status in ('present', 'absent')),
  note text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (student_id, attendance_date)
);

create table if not exists public.app_user_roles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role text not null check (role in ('admin', 'students_only')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_finances_date on public.finances(transaction_date);
create index if not exists idx_finances_type on public.finances(type);
create index if not exists idx_attendance_date on public.attendance(attendance_date);
create index if not exists idx_attendance_batch_date on public.attendance(batch, attendance_date);
create index if not exists idx_students_status on public.students(status);
create index if not exists idx_students_batch on public.students(batch);
create index if not exists idx_app_user_roles_role on public.app_user_roles(role);

drop trigger if exists trg_students_updated_at on public.students;
create trigger trg_students_updated_at
before update on public.students
for each row execute function public.set_updated_at();

drop trigger if exists trg_finances_updated_at on public.finances;
create trigger trg_finances_updated_at
before update on public.finances
for each row execute function public.set_updated_at();

drop trigger if exists trg_attendance_updated_at on public.attendance;
create trigger trg_attendance_updated_at
before update on public.attendance
for each row execute function public.set_updated_at();

drop trigger if exists trg_app_user_roles_updated_at on public.app_user_roles;
create trigger trg_app_user_roles_updated_at
before update on public.app_user_roles
for each row execute function public.set_updated_at();

alter table public.students enable row level security;
alter table public.finances enable row level security;
alter table public.attendance enable row level security;
alter table public.app_user_roles enable row level security;

drop policy if exists students_authenticated_all on public.students;
create policy students_authenticated_all
on public.students
for all
to authenticated
using (auth.role() = 'authenticated')
with check (auth.role() = 'authenticated');

drop policy if exists finances_authenticated_all on public.finances;
create policy finances_authenticated_all
on public.finances
for all
to authenticated
using (auth.role() = 'authenticated')
with check (auth.role() = 'authenticated');

drop policy if exists attendance_authenticated_all on public.attendance;
create policy attendance_authenticated_all
on public.attendance
for all
to authenticated
using (auth.role() = 'authenticated')
with check (auth.role() = 'authenticated');

drop policy if exists app_user_roles_read_own on public.app_user_roles;
create policy app_user_roles_read_own
on public.app_user_roles
for select
to authenticated
using (auth.uid() = app_user_roles.user_id);

drop function if exists public.list_manageable_users();
create or replace function public.list_manageable_users()
returns table (
  user_id uuid,
  email text,
  role text,
  created_at timestamptz
)
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if not exists (
    select 1
    from public.app_user_roles as aur
    where aur.user_id = auth.uid() and aur.role = 'admin'
  ) then
    raise exception 'Only admins can view user access.';
  end if;

  return query
  select
    u.id::uuid as user_id,
    coalesce(u.email, '')::text as email,
    aur.role::text as role,
    u.created_at::timestamptz as created_at
  from auth.users u
  left join public.app_user_roles as aur on aur.user_id = u.id
  where u.deleted_at is null
  order by u.created_at asc;
end;
$$;

revoke all on function public.list_manageable_users() from public;
grant execute on function public.list_manageable_users() to authenticated;

drop function if exists public.upsert_user_role(uuid, text);
create or replace function public.upsert_user_role(p_user_id uuid, p_role text)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if not exists (
    select 1
    from public.app_user_roles as aur
    where aur.user_id = auth.uid() and aur.role = 'admin'
  ) then
    raise exception 'Only admins can update user access.';
  end if;

  if p_role not in ('admin', 'students_only') then
    raise exception 'Invalid role. Allowed values: admin, students_only.';
  end if;

  if not exists (
    select 1
    from auth.users u
    where u.id = p_user_id and u.deleted_at is null
  ) then
    raise exception 'User not found.';
  end if;

  insert into public.app_user_roles (user_id, role)
  values (p_user_id, p_role)
  on conflict (user_id)
  do update
  set
    role = excluded.role,
    updated_at = now();
end;
$$;

revoke all on function public.upsert_user_role(uuid, text) from public;
grant execute on function public.upsert_user_role(uuid, text) to authenticated;

-- Example role assignment (run with SQL editor/service role):
-- insert into public.app_user_roles (user_id, role)
-- values ('<auth_user_uuid>', 'students_only')
-- on conflict (user_id)
-- do update set role = excluded.role, updated_at = now();

-- Refresh PostgREST schema cache in Supabase after DDL changes
notify pgrst, 'reload schema';
