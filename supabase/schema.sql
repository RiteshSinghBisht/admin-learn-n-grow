-- Learn N Grow schema (incremental numeric IDs)
-- NOTE: This script drops and recreates students/finances/attendance tables.

-- Keep updated_at consistent
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- Recreate tables so ID type is guaranteed as BIGINT identity
drop table if exists public.attendance;
drop table if exists public.finances;
drop table if exists public.students;

create table public.students (
  id bigint generated by default as identity primary key,
  name text not null,
  phone text not null,
  batch text not null default 'morning' check (batch in ('morning', 'evening')),
  join_date date not null default current_date,
  status text not null default 'active' check (status in ('active', 'inactive')),
  monthly_fee numeric(12,2) not null default 3000 check (monthly_fee >= 0),
  teacher text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table public.finances (
  id bigint generated by default as identity primary key,
  transaction_date date not null default current_date,
  category text not null,
  type text not null check (type in ('income', 'expense')),
  amount numeric(12,2) not null check (amount >= 0),
  status text not null default 'paid' check (status in ('paid', 'pending')),
  description text,
  note text,
  student_id bigint references public.students(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  check (
    (category = 'Student Fee' and type = 'income')
    or (category <> 'Student Fee')
  )
);

create table public.attendance (
  id bigint generated by default as identity primary key,
  student_id bigint not null references public.students(id) on delete cascade,
  student_name text not null,
  batch text not null default 'morning' check (batch in ('morning', 'evening')),
  teacher text,
  attendance_date date not null,
  status text not null check (status in ('present', 'absent')),
  note text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (student_id, attendance_date)
);

create table if not exists public.app_user_roles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role text not null check (role in ('admin', 'students_only')),
  assigned_teachers text[] not null default '{}'::text[],
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.app_user_roles
  add column if not exists assigned_teachers text[] not null default '{}'::text[];

update public.app_user_roles
set assigned_teachers = '{}'::text[]
where assigned_teachers is null;

alter table public.app_user_roles
  drop constraint if exists app_user_roles_role_check;

alter table public.app_user_roles
  add constraint app_user_roles_role_check
  check (role in ('admin', 'students_only'));

create index if not exists idx_finances_date on public.finances(transaction_date);
create index if not exists idx_finances_type on public.finances(type);
create index if not exists idx_attendance_date on public.attendance(attendance_date);
create index if not exists idx_attendance_batch_date on public.attendance(batch, attendance_date);
create index if not exists idx_attendance_teacher_date on public.attendance(teacher, attendance_date);
create index if not exists idx_students_status on public.students(status);
create index if not exists idx_students_batch on public.students(batch);
create index if not exists idx_students_teacher on public.students(teacher);
create index if not exists idx_app_user_roles_role on public.app_user_roles(role);
create index if not exists idx_app_user_roles_assigned_teachers on public.app_user_roles using gin (assigned_teachers);

drop trigger if exists trg_students_updated_at on public.students;
create trigger trg_students_updated_at
before update on public.students
for each row execute function public.set_updated_at();

drop trigger if exists trg_finances_updated_at on public.finances;
create trigger trg_finances_updated_at
before update on public.finances
for each row execute function public.set_updated_at();

drop trigger if exists trg_attendance_updated_at on public.attendance;
create trigger trg_attendance_updated_at
before update on public.attendance
for each row execute function public.set_updated_at();

drop trigger if exists trg_app_user_roles_updated_at on public.app_user_roles;
create trigger trg_app_user_roles_updated_at
before update on public.app_user_roles
for each row execute function public.set_updated_at();

alter table public.students enable row level security;
alter table public.finances enable row level security;
alter table public.attendance enable row level security;
alter table public.app_user_roles enable row level security;

drop policy if exists students_authenticated_all on public.students;
create policy students_authenticated_all
on public.students
for all
to authenticated
using (auth.role() = 'authenticated')
with check (auth.role() = 'authenticated');

drop policy if exists finances_authenticated_all on public.finances;
create policy finances_authenticated_all
on public.finances
for all
to authenticated
using (auth.role() = 'authenticated')
with check (auth.role() = 'authenticated');

drop policy if exists attendance_authenticated_all on public.attendance;
create policy attendance_authenticated_all
on public.attendance
for all
to authenticated
using (auth.role() = 'authenticated')
with check (auth.role() = 'authenticated');

drop policy if exists app_user_roles_read_own on public.app_user_roles;
create policy app_user_roles_read_own
on public.app_user_roles
for select
to authenticated
using (auth.uid() = app_user_roles.user_id);

drop function if exists public.list_manageable_users();
create or replace function public.list_manageable_users()
returns table (
  user_id uuid,
  email text,
  role text,
  assigned_teachers text[],
  created_at timestamptz
)
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if not exists (
    select 1
    from public.app_user_roles as aur
    where aur.user_id = auth.uid() and aur.role = 'admin'
  ) then
    raise exception 'Only admins can view user access.';
  end if;

  return query
  select
    u.id::uuid as user_id,
    coalesce(u.email, '')::text as email,
    aur.role::text as role,
    coalesce(aur.assigned_teachers, '{}'::text[])::text[] as assigned_teachers,
    u.created_at::timestamptz as created_at
  from auth.users u
  left join public.app_user_roles as aur on aur.user_id = u.id
  where u.deleted_at is null
  order by u.created_at asc;
end;
$$;

revoke all on function public.list_manageable_users() from public;
grant execute on function public.list_manageable_users() to authenticated;

drop function if exists public.upsert_user_role(uuid, text);
drop function if exists public.upsert_user_role(uuid, text, text[]);
create or replace function public.upsert_user_role(
  p_user_id uuid,
  p_role text,
  p_assigned_teachers text[] default '{}'::text[]
)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  normalized_assigned_teachers text[] := '{}';
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if not exists (
    select 1
    from public.app_user_roles as aur
    where aur.user_id = auth.uid() and aur.role = 'admin'
  ) then
    raise exception 'Only admins can update user access.';
  end if;

  if p_role not in ('admin', 'students_only') then
    raise exception 'Invalid role. Allowed values: admin, students_only.';
  end if;

  if not exists (
    select 1
    from auth.users u
    where u.id = p_user_id and u.deleted_at is null
  ) then
    raise exception 'User not found.';
  end if;

  if p_role = 'students_only' then
    select coalesce(array_agg(distinct trimmed_teacher), '{}'::text[])
    into normalized_assigned_teachers
    from (
      select btrim(raw_teacher) as trimmed_teacher
      from unnest(coalesce(p_assigned_teachers, '{}'::text[])) as raw_teacher
    ) as normalized_teachers
    where trimmed_teacher <> '';

    if coalesce(array_length(normalized_assigned_teachers, 1), 0) = 0 then
      raise exception 'At least one assigned teacher is required for Student Only access.';
    end if;
  end if;

  insert into public.app_user_roles (user_id, role, assigned_teachers)
  values (
    p_user_id,
    p_role,
    case when p_role = 'students_only' then normalized_assigned_teachers else '{}'::text[] end
  )
  on conflict (user_id)
  do update
  set
    role = excluded.role,
    assigned_teachers = excluded.assigned_teachers,
    updated_at = now();
end;
$$;

revoke all on function public.upsert_user_role(uuid, text, text[]) from public;
grant execute on function public.upsert_user_role(uuid, text, text[]) to authenticated;

-- Example role assignment (run with SQL editor/service role):
-- insert into public.app_user_roles (user_id, role, assigned_teachers)
-- values ('<auth_user_uuid>', 'teacher', array['Neha Verma', 'Rahul Mehta'])
-- on conflict (user_id)
-- do update set role = excluded.role, assigned_teachers = excluded.assigned_teachers, updated_at = now();

-- Refresh PostgREST schema cache in Supabase after DDL changes
notify pgrst, 'reload schema';
